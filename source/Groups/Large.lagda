sMartin Escardo
15 February 2021.

In collaboration with Marc Bezem, Thierry Coquand and Peter Dybjer.

This module has the technical lemmas necessary to prove the
following:

  For any universe 𝓤, there is a group in the successor universe 𝓤⁺
  which is not isomorphic to any group in 𝓤.

Of course, in the other direction, any group in 𝓤 has an isomorphic
copy in 𝓤⁺, so the above says that there are strictly more groups in
𝓤⁺ than in 𝓤.

In the module BuraliForti we use the group freely generated by
the (large but locally small) set of ordinals for that purpose.

We work in a spartan Martin-Löf type theory, with the assumption that
propositional truncations exist and that the univalence axiom
holds. No other features of HoTT/UF are needed.

In particular, quotients, which we use to construct free groups, are
constructed using propositional truncation and function extensionality
and propositional extensionality in the module UF.LargeQuotient. This
construction of quotients increases the universe level by one (but its
universal property eliminates into any universe), so that the group
freely generated by a type A in a universe 𝓤 lives in the next
universe 𝓤⁺ (but again its universal property eliminates into any
universe).

In this file with work with a given locally small type A : 𝓤⁺ for an
arbitrary universe 𝓤 and we show that the free group constructed in
the module Group.Free, which lives in the universe 𝓤⁺⁺, has a
copy in the same universe 𝓤⁺ where A lives, provided A is locally
small (meaning that its identity types, which live in 𝓤⁺, have
equivalent copies in 𝓤). Moreover, we show that if the group freely
generated by A has a copy in the universe 𝓤, then A itself must have a
copy in 𝓤.  We then apply this in the module BuraliForti by
taking A to be the type of ordinals in the universe 𝓤, which doesn't
have a copy in 𝓤, from which we conclude that the free group also
doesn't have a copy in 𝓤.

For that purpose, we need to know, in particular, that the inclusion
of generators is injective, which is proved in the module
Group.Free. But this is is not enough: for example, the unique
map P → 𝟙 is an embedding if P is a proposition, and the terminal
type 𝟙 is of course small, but P doesn't need to be small - cf. work
with Tom de Jong on size matters https://arxiv.org/abs/2102.08812,
from which we borrow other techniques in the development below.

\begin{code}

{-# OPTIONS --safe --without-K #-}

open import MLTT.Spartan
open import UF.FunExt
open import UF.PropTrunc
open import UF.Subsingletons

module Groups.Large
        (fe : Fun-Ext)
        (pe : Prop-Ext)
        (pt : propositional-truncations-exist)
       where

open import Groups.Free
open import Groups.Type
open import MLTT.List
open import Quotient.Large pt fe pe
open import Quotient.Type
open import Relations.SRTclosure
open import UF.Base
open import UF.Embeddings
open import UF.Equiv hiding (_≅_)
open import UF.EquivalenceExamples
open import UF.Sets
open import UF.Size
open import UF.SmallnessProperties

open FreeGroupInterface pt fe (_⁺) large-set-quotients large-effective-set-quotients

private

 fe' : FunExt
 fe' 𝓤 𝓥 = fe {𝓤} {𝓥}

 pe' : PropExt
 pe' 𝓤 = pe {𝓤}

\end{code}

The last three assumptions in the following module parameters are a
slight weakening of the local smallness condition on the type A.

\begin{code}

module resize-free-group'
         {𝓤        : Universe}
         (A        : 𝓤 ⁺ ̇)
         (_＝₀_    : A → A → 𝓤 ̇ )
         (refl₀    : (a : A) → a ＝₀ a)
         (from-＝₀ : (a b : A) → a ＝₀ b → a ＝ b)
       where

 open free-group-construction A

 private
  𝓤⁺  = 𝓤 ⁺
  𝓤⁺⁺ = 𝓤⁺ ⁺

\end{code}

Next we want to show that the underlying set of the above free group
doesn't have a copy in 𝓤 (we say that this set is large).

It may happen that for an embedding f : X → Y, the type X is large but
the type Y is small. This is the case, for instance, if X is a
proposition, Y is the unit type, and f is the unique map.

We say that a type has size 𝓥 if it is equivalent to some type in the
universe 𝓥, and that a map has size 𝓥 if its fibers all have size 𝓥.
See the module UF.Size. This notion of size for maps is introduced and
developed in the paper https://dx.doi.org/10.4230/LIPIcs.FSCD.2021.8
by Tom de Jong and Martin Escardo.

The native size of the universal map ηᴳʳᵖ : A → FA/∾ into the free
group is rather large - it jumps up two universe levels:

\begin{code}

 open resize-free-group fe pe pt A _＝₀_ refl₀ from-＝₀ public
 open general-set-quotients-exist large-set-quotients
 open free-group-construction-step₁ pt
 open free-group-construction-step₂ fe (_⁺)
  large-set-quotients
  large-effective-set-quotients

 NB-ηᴳʳᵖ-native-size : ηᴳʳᵖ is 𝓤⁺⁺ small-map
 NB-ηᴳʳᵖ-native-size = native-size-of-map ηᴳʳᵖ

\end{code}

Using the above development, we can make it smaller.

In the following, the function η/∾ : FA → FA/∾ is the universal map
into the quotient (constructed in the module Groups.FreeGroup), and,
by definition, the universal map ηᴳʳᵖ : A → FA/∾ into the free group
is the composite η/∾ ∘ η where η : A → FA is the insertion of
generators before quotienting and η/∾ is the universal map into the
quotient.

\begin{code}

 module _ (A-is-set : is-set A) where

  smallness-of-ηᴳʳᵖ-fibers-is-prop : {𝓦 : Universe} (y : FA/∾)
                                   → is-prop (fiber ηᴳʳᵖ y is 𝓦 small)
  smallness-of-ηᴳʳᵖ-fibers-is-prop y = prop-being-small-is-prop pe' fe'
                                        (fiber ηᴳʳᵖ y)
                                        (ηᴳʳᵖ-is-embedding A-is-set y)

\end{code}

The following remark is proved by quotient induction, which says that
in order to prove a property of all elements of the quotient, it
suffices to prove it for elements of the form η/∾ s with s : FA.

\begin{code}

  NB-ηᴳʳᵖ-is-medium : ηᴳʳᵖ is 𝓤⁺ small-map
  NB-ηᴳʳᵖ-is-medium = /-induction -∾-
                       smallness-of-ηᴳʳᵖ-fibers-is-prop
                       induction-step
   where
    III : (a : A) (s : FA) → (η/∾ (η a) ＝ η/∾ s) ≃ (η a ∥≏∥ s)
    III a s = (η/∾ (η a) ＝ η/∾ s) ≃⟨ I ⟩
              (η a ∾ s)            ≃⟨ II ⟩
              (η a ∥≏∥ s)          ■
     where
      I = logically-equivalent-props-are-equivalent
           (/-is-set -∾-)
           ∥∥-is-prop
           η/∾-relates-identified-points
           η/∾-identifies-related-points
      II = ∿-is-equivalent-to-∥≏∥ (η a) s

    IV : (s : FA) → fiber ηᴳʳᵖ (η/∾ s) ≃ (Σ a ꞉ A , η a ∥≏∥ s)
    IV s = (Σ a ꞉ A , η/∾ (η a) ＝ η/∾ s) ≃⟨ Σ-cong (λ a → III a s) ⟩
           (Σ a ꞉ A , η a ∥≏∥ s)          ■

    notice : (s : FA) → universe-of (fiber ηᴳʳᵖ (η/∾ s)) ＝ 𝓤⁺⁺
    notice s = refl

    induction-step : (s : FA) → fiber ηᴳʳᵖ (η/∾ s) is 𝓤⁺ small
    induction-step s = (Σ a ꞉ A , η a ∥≏∥ s) , ≃-sym (IV s)

\end{code}

But the above resizing of the map ηᴳʳᵖ is not small enough for our
purposes. Recall that ηᴳʳᵖ a = η/∾ (η a). We first discuss the fibers
of η, then those of η/∾, and finally those of ηᴳʳᵖ.

The fiber type Σ a ꞉ A , η a ＝ s lives in the universe 𝓤⁺. In the next
step we construct a copy of this fiber type in the first universe 𝓤₀.

The following construction also shows that the map η : A → FA has
decidable fibers, which is used implicitly in our definitions by
pattern matching.

\begin{code}

  NB-native-universe-fiber-η : (s : FA) → universe-of (fiber η s) ＝ 𝓤⁺
  NB-native-universe-fiber-η s = refl

  η-is-decidable : each-fiber-of η is-decidable
  η-is-decidable = ∘-decidable-embeddings
                    []-is-embedding
                    pair₀-is-decidable
                    []-is-decidable

  η-is-embedding : is-embedding η
  η-is-embedding = ∘-is-embedding pair₀-is-embedding []-is-embedding

  η-has-any-size : (𝓦 : Universe) → η is 𝓦 small-map
  η-has-any-size 𝓦 = decidable-embeddings-have-any-size 𝓦
                       η-is-embedding
                       η-is-decidable
\end{code}

Using this, next we want to reduce the size of the type
Σ a ꞉ A , η a ∾ s, which we informally refer to
as "the ∾-fiber of s over η". First, this type is a proposition:

\begin{code}

  the-∾-fibers-of-η-are-props : (s : FA) → is-prop (Σ a ꞉ A , η a ∾ s)
  the-∾-fibers-of-η-are-props s (a , e) (a' , e') = γ
   where
    α : η a ∾ η a'
    α = psrt-transitive (η a) s (η a') e (psrt-symmetric (η a') s e')

    β : a ＝ a'
    β = η-identifies-∾-related-points A-is-set α

    γ : (a , e) ＝ (a' , e')
    γ = to-subtype-＝ (λ x → ∥∥-is-prop) β

  generator : FA → 𝓤 ⁺ ̇
  generator s = Σ n ꞉ ℕ , Σ ρ ꞉ redex-chain n s , fiber η (chain-reduct s n ρ)

  is-generator : FA → 𝓤 ⁺ ̇
  is-generator s = ∥ generator s ∥

  being-generator-is-small : (s : FA) → is-generator s is 𝓤 small
  being-generator-is-small s =
   ∥∥-is-small pt
    (Σ-is-small
      (native-size ℕ)
      (λ n → Σ-is-small
              (native-size (redex-chain n s))
              (λ ρ → η-has-any-size 𝓤 (chain-reduct s n ρ))))

  ∾-fiber-η-lemma→ : (s : FA) → (Σ a ꞉ A , η a ∾ s) → is-generator s
  ∾-fiber-η-lemma→ s (a , e) = ∥∥-functor γ e
   where
    γ : η a ∿ s → generator s
    γ e = δ (d c)
     where
      c : Σ u ꞉ FA , (η a ▷⋆ u) × (s ▷⋆ u)
      c = from-∿ Church-Rosser (η a) s e

      d : type-of c → Σ n ꞉ ℕ , Σ ρ ꞉ redex-chain n s , chain-reduct s n ρ ＝ η a
      d (u , r , r₁) = δ r₂
       where
        p : η a ＝ u
        p = η-irreducible⋆ r

        r₂ : s  ▷⋆ η a
        r₂ = transport (s ▷⋆_) (p ⁻¹) r₁

        δ : s  ▷⋆ η a → Σ n ꞉ ℕ , Σ ρ ꞉ redex-chain n s , chain-reduct s n ρ ＝ η a
        δ (n , r₃) = (n , chain-lemma← s (η a) n r₃)

      δ : type-of (d c) → generator s
      δ (n , ρ , p) = n , ρ , a , (p ⁻¹)

  ∾-fiber-η-lemma← : (s : FA) → is-generator s → (Σ a ꞉ A , η a ∾ s)
  ∾-fiber-η-lemma← s = ∥∥-rec (the-∾-fibers-of-η-are-props s) γ
   where
    γ : generator s → (Σ a ꞉ A , η a ∾ s)
    γ (n , ρ , i) = δ i
     where
      r : s ▷[ n ] chain-reduct s n ρ
      r = chain-lemma→ s n ρ

      e : chain-reduct s n ρ ∾ s
      e = ∣ to-∿ (chain-reduct s n ρ) s (chain-reduct s n ρ , (0 , refl) , (n , r)) ∣

      δ : fiber η (chain-reduct s n ρ) → Σ a ꞉ A , η a ∾ s
      δ (a , p) = a , transport (_∾ s) (p ⁻¹) e

\end{code}

And this is the desired size reduction:

\begin{code}

  ∾-fiber-η-lemma : (s : FA) → (Σ a ꞉ A , η a ∾ s) ≃ is-generator s
  ∾-fiber-η-lemma s = logically-equivalent-props-are-equivalent
                       (the-∾-fibers-of-η-are-props s)
                       ∥∥-is-prop
                       (∾-fiber-η-lemma→ s)
                       (∾-fiber-η-lemma← s)
\end{code}

With this we can further reduce the size of the universal map ηᴳʳᵖ:

\begin{code}

  fiber-η/∾-lemma : (a : A) (s : FA) → (η/∾ (η a) ＝ η/∾ s) ≃ (η a ∾ s)
  fiber-η/∾-lemma a s = logically-equivalent-props-are-equivalent
                         (/-is-set -∾-)
                         ∥∥-is-prop
                         η/∾-relates-identified-points
                         η/∾-identifies-related-points

  fiber-ηηᴳʳᵖ-lemma : (s : FA) → fiber ηᴳʳᵖ (η/∾ s) ≃ is-generator s
  fiber-ηηᴳʳᵖ-lemma s =
   (Σ a ꞉ A , η/∾ (η a) ＝ η/∾ s) ≃⟨ Σ-cong (λ a → fiber-η/∾-lemma a s) ⟩
   (Σ a ꞉ A , η a ∾ s)            ≃⟨ ∾-fiber-η-lemma s ⟩
   is-generator s                 ■

  the-ηᴳʳᵖ-fibers-of-equivalence-classes-are-small : (s : FA)
                                                   → fiber ηᴳʳᵖ (η/∾ s) is 𝓤 small
  the-ηᴳʳᵖ-fibers-of-equivalence-classes-are-small s =
   smallness-closed-under-≃'
    (being-generator-is-small s)
    (fiber-ηηᴳʳᵖ-lemma s)

  ηᴳʳᵖ-is-small : ηᴳʳᵖ is 𝓤 small-map
  ηᴳʳᵖ-is-small = /-induction -∾-
                   smallness-of-ηᴳʳᵖ-fibers-is-prop
                   the-ηᴳʳᵖ-fibers-of-equivalence-classes-are-small
\end{code}

And with this we get our desired result as a corollary:

\begin{code}

  free-group-small-gives-generating-set-small : ⟨ free-group A ⟩ is 𝓤 small
                                              → A is 𝓤 small
  free-group-small-gives-generating-set-small h =
   size-contravariance ηᴳʳᵖ ηᴳʳᵖ-is-small h

\end{code}

It follows that if there is a large, locally small set, then there is
a large group:

\begin{code}

large-group-with-no-small-copy : (Σ A ꞉ 𝓤 ⁺ ̇  , is-set A
                                              × is-large A
                                              × is-locally-small A)
                               → Σ F ꞉ Group (𝓤 ⁺) , ((G : Group 𝓤) → ¬ (G ≅ F))

large-group-with-no-small-copy {𝓤} (A , A-is-set , A-is-large , A-ls) = δ
 where
  open resize-free-group'
        A
        Id⟦ A-ls ⟧
        (λ _ → ⟦ A-ls ⟧-refl)
        (λ _ _ p → ＝⟦ A-ls ⟧-gives-＝ p)

  γ : (Σ F ꞉ Group (𝓤 ⁺) , F ≅ free-group A)
    → (Σ F ꞉ Group (𝓤 ⁺) , ((G : Group 𝓤) → ¬ (G ≅ F)))
  γ (F , f , f-is-equiv , f-is-hom) = F , β
   where
    β : (G : Group 𝓤) → G ≅ F → 𝟘
    β G (g , g-is-equiv , g-is-hom) = α
     where
      h : ⟨ free-group A ⟩ is 𝓤 small
      h = ⟨ G ⟩ , f ∘ g , ∘-is-equiv g-is-equiv f-is-equiv

      α : 𝟘
      α = A-is-large (free-group-small-gives-generating-set-small A-is-set h)

  δ : codomain γ
  δ = γ small-free-group

\end{code}

In the module BuraliForti we instantiate A to the set of ordinals,
which is large and locally small, to construct a large group with no
small copy.

Remarks.

What can we choose for the large, locally small set?

 * Our choice is the type of ordinals.

 * One may wonder whether there are simpler choices such as

    (i)   The function type 𝓤 → 𝟚.
    (ii)  The function type 𝓤 → Ω 𝓤.
    (iii) The set truncation of 𝓤.

   The candidate (i) doesn't work in the absence of classical logic,
   because there is a non-constant function 𝓤 → 𝟚 if and only if de
   Morgan Law holds (which is equivalent to excluded middle for
   negative propositions). https://doi.org/10.1016/j.apal.2016.04.010

   The candidates (ii) and (iii) may work, but so far we haven't succeeded.

 * Another question is whether there is a large, discrete set, as this
   would considerably simplify the construction of the free group. One
   of us conjectures that there isn't, in general, such a set.
