Martin Escardo, 04 January 2021.

Ongoing joint work with Marc Bezem, Thierry Coquand, and Peter Dybjer.

We construct free groups in HoTT/UF in Agda without HIT's other than
propositional truncation.

Based on Richman's book on constructive algebra.

For the moment this file is not for public consumption, but it is
publicly visible.

This is part of the Martin Escardo's Agda development TypeTopology,
whose philosophy is to be Spartan. At the moment we are a bit
Athenian, though, although we intend to fix this in the
future.

\begin{code}

{-# OPTIONS --without-K --safe #-} -- --exact-split

\end{code}

NB. This repository is supposed to use exact-split, but even though
everything has been developed using case-split, the exact-split check
fails (in Agda 2.6.1) in the helper function f of the function
churros. This seems to be a bug.

\begin{code}

module FreeGroup where

open import SpartanMLTT
open import Two
open import Two-Properties

open import UF-PropTrunc
open import UF-Univalence
open import UF-Base
open import UF-Subsingletons
open import UF-Equiv
open import UF-UA-FunExt
open import UF-FunExt

\end{code}

It is possible to work with lists *defined* from the ingredients of
our Spartan MLTT (see the module Fin.lagda). For the moment we are
Athenian in this respect:

\begin{code}

data List {ùì§} (X : ùì§ Ãá ) : ùì§ Ãá  where
 [] : List X
 _‚à∑_ : X ‚Üí List X ‚Üí List X

infixr 3 _‚à∑_

equal-heads : {X : ùì§ Ãá } {x y : X} {s t : List X}
            ‚Üí x ‚à∑ s ‚â° y ‚à∑ t
            ‚Üí x ‚â° y
equal-heads refl = refl

equal-tails : {X : ùì§ Ãá } {x y : X} {s t : List X}
            ‚Üí x ‚à∑ s ‚â° y ‚à∑ t
            ‚Üí s ‚â° t
equal-tails {ùì§} {X} refl = refl

[_] : {X : ùì§ Ãá } ‚Üí X ‚Üí List X
[ x ] = x ‚à∑ []

_++_ : {X : ùì§ Ãá } ‚Üí List X ‚Üí List X ‚Üí List X
[]      ++ t = t
(x ‚à∑ s) ++ t = x ‚à∑ (s ++ t)

infixr 4 _++_

[]-right-neutral : {X : ùì§ Ãá } (s : List X) ‚Üí s ‚â° s ++ []
[]-right-neutral []      = refl
[]-right-neutral (x ‚à∑ s) = ap (x ‚à∑_) ([]-right-neutral s)

++-assoc : {X : ùì§ Ãá } ‚Üí associative (_++_ {ùì§} {X})
++-assoc []      t u = refl
++-assoc (x ‚à∑ s) t u = ap (x ‚à∑_) (++-assoc s t u)

\end{code}

We now construct the group freely generated by a set A. The set-hood
requirement is needed later only, and so we don't include it as an
assumption in the following anonymous module:

\begin{code}

module _ {ùì§ : Universe}
         {A : ùì§ Ãá }
       where

 X : ùì§ Ãá
 X = ùüö √ó A

 _‚Åª : X ‚Üí X
 (n , a)‚Åª = (complement n , a)

 inv-invol : (x : X) ‚Üí (x ‚Åª)‚Åª ‚â° x
 inv-invol (n , a) = ap (_, a) (complement-involutive n)

\end{code}

We will quotient the following type FA to get the undelying type of
the free group:

\begin{code}

 FA : ùì§ Ãá
 FA = List X

 Œ∑ : A ‚Üí FA
 Œ∑ a = [ ‚ÇÄ , a ]

\end{code}

We will quotient by the equivalence relation generated by the
following reduction relation:

\begin{code}

 _‚ñ∑_ : FA ‚Üí FA ‚Üí ùì§ Ãá
 s ‚ñ∑ t = Œ£ u Íûâ FA , Œ£ v Íûâ FA , Œ£ x Íûâ X , (s ‚â° u ++ [ x ] ++ [ x ‚Åª ] ++ v)
                                       √ó (t ‚â° u ++ v)

 infix 1 _‚ñ∑_

 ‚à∑-‚ñ∑ : {s t : FA} (x : X) ‚Üí s ‚ñ∑ t ‚Üí x ‚à∑ s ‚ñ∑ x ‚à∑ t
 ‚à∑-‚ñ∑ x (u , v , y , p , q) = (x ‚à∑ u) , v , y , ap (x ‚à∑_) p , ap (x ‚à∑_) q

\end{code}

The following is a lemma for the Church-Rosser property, proved by
induction on u‚ÇÄ and u‚ÇÅ:

\begin{code}

 churros : (u‚ÇÄ v‚ÇÄ u‚ÇÅ v‚ÇÅ : FA) (x‚ÇÄ x‚ÇÅ : X)

         ‚Üí u‚ÇÄ ++  [ x‚ÇÄ ] ++ [ x‚ÇÄ ‚Åª ] ++ v‚ÇÄ
         ‚â° u‚ÇÅ ++  [ x‚ÇÅ ] ++ [ x‚ÇÅ ‚Åª ] ++ v‚ÇÅ

         ‚Üí (u‚ÇÄ ++ v‚ÇÄ ‚â° u‚ÇÅ ++ v‚ÇÅ)
         + (Œ£ t Íûâ FA , (u‚ÇÄ ++ v‚ÇÄ ‚ñ∑ t) √ó (u‚ÇÅ ++ v‚ÇÅ ‚ñ∑ t))

 churros u‚ÇÄ v‚ÇÄ u‚ÇÅ v‚ÇÅ x‚ÇÄ x‚ÇÅ = f u‚ÇÄ u‚ÇÅ
  where
   f : (u‚ÇÄ u‚ÇÅ : FA)
     ‚Üí u‚ÇÄ ++  [ x‚ÇÄ ] ++ [ x‚ÇÄ ‚Åª ] ++ v‚ÇÄ ‚â° u‚ÇÅ ++  [ x‚ÇÅ ] ++ [ x‚ÇÅ ‚Åª ] ++ v‚ÇÅ
     ‚Üí (u‚ÇÄ ++ v‚ÇÄ ‚â° u‚ÇÅ ++ v‚ÇÅ) + (Œ£ t Íûâ FA , (u‚ÇÄ ++ v‚ÇÄ ‚ñ∑ t) √ó (u‚ÇÅ ++ v‚ÇÅ ‚ñ∑ t))

   f [] [] p = inl Œ≥
    where
     have : x‚ÇÄ ‚à∑ x‚ÇÄ ‚Åª  ‚à∑ v‚ÇÄ
          ‚â° x‚ÇÅ ‚à∑ x‚ÇÅ ‚Åª  ‚à∑ v‚ÇÅ
     have = p

     Œ≥ : v‚ÇÄ ‚â° v‚ÇÅ
     Œ≥ = equal-tails (equal-tails p)

   f [] (y‚ÇÅ ‚à∑ []) p = inl Œ≥
    where
     have : x‚ÇÄ ‚à∑ x‚ÇÄ ‚Åª ‚à∑ v‚ÇÄ
          ‚â° y‚ÇÅ ‚à∑ x‚ÇÅ   ‚à∑ x‚ÇÅ ‚Åª ‚à∑ v‚ÇÅ
     have = p

     q = x‚ÇÅ ‚Åª    ‚â°‚ü® ap _‚Åª ((equal-heads (equal-tails p))‚Åª¬π) ‚ü©
         (x‚ÇÄ ‚Åª)‚Åª ‚â°‚ü® inv-invol x‚ÇÄ ‚ü©
         x‚ÇÄ      ‚â°‚ü® equal-heads p ‚ü©
         y‚ÇÅ      ‚àé

     Œ≥ : v‚ÇÄ ‚â° y‚ÇÅ ‚à∑ v‚ÇÅ
     Œ≥ = transport (Œª - ‚Üí v‚ÇÄ ‚â° - ‚à∑ v‚ÇÅ) q (equal-tails (equal-tails p))

   f [] (y‚ÇÅ ‚à∑ z‚ÇÅ ‚à∑ u‚ÇÅ) p = inr Œ≥
    where
     have : x‚ÇÄ ‚à∑ x‚ÇÄ ‚Åª ‚à∑ v‚ÇÄ
          ‚â° y‚ÇÅ ‚à∑ z‚ÇÅ   ‚à∑ u‚ÇÅ ++ [ x‚ÇÅ ] ++ [ x‚ÇÅ ‚Åª ] ++ v‚ÇÅ
     have = p

     d' : u‚ÇÅ ++ [ x‚ÇÅ ] ++ [ x‚ÇÅ ‚Åª ] ++ v‚ÇÅ ‚ñ∑ u‚ÇÅ ++ v‚ÇÅ
     d' = u‚ÇÅ , v‚ÇÅ , x‚ÇÅ , refl , refl

     d : v‚ÇÄ ‚ñ∑ u‚ÇÅ ++ v‚ÇÅ
     d = transport (_‚ñ∑ u‚ÇÅ ++ v‚ÇÅ) ((equal-tails (equal-tails p))‚Åª¬π) d'

     q = y‚ÇÅ ‚Åª ‚â°‚ü® (ap (_‚Åª) (equal-heads p)‚Åª¬π) ‚ü©
         x‚ÇÄ ‚Åª ‚â°‚ü® equal-heads (equal-tails p) ‚ü©
         z‚ÇÅ   ‚àé

     e' : y‚ÇÅ ‚à∑ y‚ÇÅ ‚Åª ‚à∑ u‚ÇÅ ++ v‚ÇÅ ‚ñ∑ u‚ÇÅ ++ v‚ÇÅ
     e' = [] , (u‚ÇÅ ++ v‚ÇÅ) , y‚ÇÅ , refl , refl

     e : y‚ÇÅ ‚à∑ z‚ÇÅ ‚à∑ u‚ÇÅ ++ v‚ÇÅ ‚ñ∑ u‚ÇÅ ++ v‚ÇÅ
     e = transport (Œª - ‚Üí y‚ÇÅ ‚à∑ - ‚à∑ u‚ÇÅ ++ v‚ÇÅ ‚ñ∑ u‚ÇÅ ++ v‚ÇÅ) q e'

     Œ≥ : Œ£ t Íûâ FA , (v‚ÇÄ ‚ñ∑ t) √ó (y‚ÇÅ ‚à∑ z‚ÇÅ ‚à∑ u‚ÇÅ ++ v‚ÇÅ ‚ñ∑ t)
     Œ≥ = (u‚ÇÅ ++ v‚ÇÅ) , d , e

   f (y‚ÇÄ ‚à∑ []) [] p = inl Œ≥
    where
     have : y‚ÇÄ ‚à∑ x‚ÇÄ   ‚à∑ x‚ÇÄ ‚Åª ‚à∑ v‚ÇÄ
          ‚â° x‚ÇÅ ‚à∑ x‚ÇÅ ‚Åª ‚à∑ v‚ÇÅ
     have = p

     Œ≥ = y‚ÇÄ ‚à∑ v‚ÇÄ      ‚â°‚ü® ap (_‚à∑ v‚ÇÄ) (equal-heads p) ‚ü©
         x‚ÇÅ ‚à∑ v‚ÇÄ      ‚â°‚ü® ap (_‚à∑ v‚ÇÄ) ((inv-invol x‚ÇÅ)‚Åª¬π) ‚ü©
         (x‚ÇÅ ‚Åª)‚Åª ‚à∑ v‚ÇÄ ‚â°‚ü® ap (Œª - ‚Üí - ‚Åª ‚à∑ v‚ÇÄ) ((equal-heads (equal-tails p))‚Åª¬π) ‚ü©
         x‚ÇÄ ‚Åª ‚à∑ v‚ÇÄ    ‚â°‚ü® equal-tails (equal-tails p) ‚ü©
         v‚ÇÅ           ‚àé

   f (y‚ÇÄ ‚à∑ z‚ÇÄ ‚à∑ u‚ÇÄ) [] p = inr Œ≥
    where
     have : y‚ÇÄ ‚à∑ z‚ÇÄ   ‚à∑ u‚ÇÄ ++ [ x‚ÇÄ ] ++ [ x‚ÇÄ ‚Åª ] ++ v‚ÇÄ
          ‚â° x‚ÇÅ ‚à∑ x‚ÇÅ ‚Åª ‚à∑ v‚ÇÅ
     have = p

     q = y‚ÇÄ ‚Åª ‚â°‚ü® ap (_‚Åª) (equal-heads p) ‚ü©
         x‚ÇÅ ‚Åª ‚â°‚ü® (equal-heads (equal-tails p))‚Åª¬π ‚ü©
         z‚ÇÄ   ‚àé

     d' : y‚ÇÄ ‚à∑ y‚ÇÄ ‚Åª ‚à∑ u‚ÇÄ ++ v‚ÇÄ ‚ñ∑ u‚ÇÄ ++ v‚ÇÄ
     d' = [] , (u‚ÇÄ ++ v‚ÇÄ) , y‚ÇÄ , refl , refl

     d : y‚ÇÄ ‚à∑ z‚ÇÄ ‚à∑ u‚ÇÄ ++ v‚ÇÄ ‚ñ∑ u‚ÇÄ ++ v‚ÇÄ
     d = transport (Œª - ‚Üí y‚ÇÄ ‚à∑ - ‚à∑ u‚ÇÄ ++ v‚ÇÄ ‚ñ∑ u‚ÇÄ ++ v‚ÇÄ) q d'

     e' : u‚ÇÄ ++ [ x‚ÇÄ ] ++ [ x‚ÇÄ ‚Åª ] ++ v‚ÇÄ ‚ñ∑ u‚ÇÄ ++ v‚ÇÄ
     e' = u‚ÇÄ , v‚ÇÄ , x‚ÇÄ , refl , refl

     e : v‚ÇÅ ‚ñ∑ u‚ÇÄ ++ v‚ÇÄ
     e = transport (_‚ñ∑ u‚ÇÄ ++ v‚ÇÄ) (equal-tails (equal-tails p)) e'

     Œ≥ : Œ£ t Íûâ FA , (y‚ÇÄ ‚à∑ z‚ÇÄ ‚à∑ u‚ÇÄ ++ v‚ÇÄ ‚ñ∑ t) √ó (v‚ÇÅ ‚ñ∑ t)
     Œ≥ = (u‚ÇÄ ++ v‚ÇÄ) , d , e

   f (y‚ÇÄ ‚à∑ u‚ÇÄ) (y‚ÇÅ ‚à∑ u‚ÇÅ) p = Œ≥
    where
     have : y‚ÇÄ ‚à∑ u‚ÇÄ ++ [ x‚ÇÄ ] ++ [ x‚ÇÄ ‚Åª ] ++ v‚ÇÄ
          ‚â° y‚ÇÅ ‚à∑ u‚ÇÅ ++ [ x‚ÇÅ ] ++ [ x‚ÇÅ ‚Åª ] ++ v‚ÇÅ
     have = p

     IH : (u‚ÇÄ ++ v‚ÇÄ ‚â° u‚ÇÅ ++ v‚ÇÅ) + (Œ£ t Íûâ FA , (u‚ÇÄ ++ v‚ÇÄ ‚ñ∑ t) √ó (u‚ÇÅ ++ v‚ÇÅ ‚ñ∑ t))
     IH = f u‚ÇÄ u‚ÇÅ (equal-tails p)

     Œì : X ‚Üí X ‚Üí ùì§ Ãá
     Œì y‚ÇÄ y‚ÇÅ = (y‚ÇÄ ‚à∑ u‚ÇÄ ++ v‚ÇÄ ‚â° y‚ÇÅ ‚à∑ u‚ÇÅ ++ v‚ÇÅ)
             + (Œ£ t Íûâ FA , (y‚ÇÄ ‚à∑ u‚ÇÄ ++ v‚ÇÄ ‚ñ∑ t) √ó (y‚ÇÅ ‚à∑ u‚ÇÅ ++ v‚ÇÅ ‚ñ∑ t))

     Œ¥ : type-of IH ‚Üí ‚àÄ {y‚ÇÄ y‚ÇÅ} ‚Üí y‚ÇÄ ‚â° y‚ÇÅ ‚Üí Œì y‚ÇÄ y‚ÇÅ
     Œ¥ (inl q)           {y‚ÇÄ} refl = inl (ap (y‚ÇÄ ‚à∑_) q)
     Œ¥ (inr (t , d , e)) {y‚ÇÄ} refl = inr ((y‚ÇÄ ‚à∑ t) , ‚à∑-‚ñ∑ y‚ÇÄ d , ‚à∑-‚ñ∑ y‚ÇÄ e)

     Œ≥ : Œì y‚ÇÄ y‚ÇÅ
     Œ≥ = Œ¥ IH (equal-heads p)

 Church-Rosser : (s t‚ÇÄ t‚ÇÅ : FA)
               ‚Üí s ‚ñ∑ t‚ÇÄ
               ‚Üí s ‚ñ∑ t‚ÇÅ
               ‚Üí (t‚ÇÄ ‚â° t‚ÇÅ) + (Œ£ t Íûâ FA , (t‚ÇÄ ‚ñ∑ t) √ó (t‚ÇÅ ‚ñ∑ t))
 Church-Rosser s t‚ÇÄ t‚ÇÅ (u‚ÇÄ , v‚ÇÄ , x‚ÇÄ , p‚ÇÄ , q‚ÇÄ) (u‚ÇÅ , v‚ÇÅ , x‚ÇÅ , p‚ÇÅ , q‚ÇÅ) = Œ≥ Œ¥
  where
   Œ¥ : (u‚ÇÄ ++ v‚ÇÄ ‚â° u‚ÇÅ ++ v‚ÇÅ) + (Œ£ t Íûâ FA , (u‚ÇÄ ++ v‚ÇÄ ‚ñ∑ t) √ó (u‚ÇÅ ++ v‚ÇÅ ‚ñ∑ t))
   Œ¥ = churros u‚ÇÄ v‚ÇÄ u‚ÇÅ v‚ÇÅ x‚ÇÄ x‚ÇÅ (p‚ÇÄ ‚Åª¬π ‚àô p‚ÇÅ)

   Œ≥ : type-of Œ¥ ‚Üí (t‚ÇÄ ‚â° t‚ÇÅ) + (Œ£ t Íûâ FA , (t‚ÇÄ ‚ñ∑ t) √ó (t‚ÇÅ ‚ñ∑ t))
   Œ≥ (inl q)           = inl (q‚ÇÄ ‚àô q ‚àô q‚ÇÅ ‚Åª¬π)
   Œ≥ (inr (t , p , q)) = inr (t , transport (_‚ñ∑ t) (q‚ÇÄ ‚Åª¬π) p ,
                                  transport (_‚ñ∑ t) (q‚ÇÅ ‚Åª¬π) q)

\end{code}

The following import defines

  _‚óÅ‚ñ∑_       the symmetric closure of _‚ñ∑_,
  _‚àø_        the symmetric, reflexive, transitive closure of _‚ñ∑_,
  _‚ñ∑*_       the reflexive, transitive closure of _‚ñ∑_,
  _‚ñ∑[ n ]_   the n-fold iteration of _‚ñ∑_.
  _‚óÅ‚ñ∑[ n ]_  the n-fold iteration of _‚óÅ‚ñ∑_.

\begin{code}

 open import SRTclosure
 open Church-Rosser _‚ñ∑_

\end{code}

The insertion of generators is left cancellable before quotienting:

\begin{code}

 Œ∑-lc : {a b : A} ‚Üí Œ∑ a ‚â° Œ∑ b ‚Üí a ‚â° b
 Œ∑-lc refl = refl

\end{code}

The following will give that the insertion of generators is injective
after quotienting:

\begin{code}

 Œ∑-irreducible : {a : A} {s : FA} ‚Üí ¬¨ (Œ∑ a ‚ñ∑ s)
 Œ∑-irreducible ((x ‚à∑ []) , v , y , () , refl)
 Œ∑-irreducible ((x ‚à∑ y ‚à∑ u) , v , z , () , q)

 Œ∑-irreducible* : {a : A} {s : FA} ‚Üí Œ∑ a ‚ñ∑* s ‚Üí Œ∑ a ‚â° s
 Œ∑-irreducible* {a} {s} (n , r) = f n r
  where
   f : (n : ‚Ñï) ‚Üí Œ∑ a ‚ñ∑[ n ] s ‚Üí Œ∑ a ‚â° s
   f zero     refl = refl
   f (succ n) (t , r , i) = ùüò-elim (Œ∑-irreducible r)

 Œ∑-‚àø : {a b : A} ‚Üí Œ∑ a ‚àø Œ∑ b ‚Üí a ‚â° b
 Œ∑-‚àø {a} {b} e = Œ∑-lc p
  where
   œÉ : Œ£ s Íûâ FA , (Œ∑ a ‚ñ∑* s) √ó (Œ∑ b ‚ñ∑* s)
   œÉ = from-‚àø Church-Rosser (Œ∑ a) (Œ∑ b) e
   s = pr‚ÇÅ œÉ

   p = Œ∑ a ‚â°‚ü®  Œ∑-irreducible* (pr‚ÇÅ (pr‚ÇÇ œÉ)) ‚ü©
       s   ‚â°‚ü® (Œ∑-irreducible* (pr‚ÇÇ (pr‚ÇÇ œÉ)))‚Åª¬π ‚ü©
       Œ∑ b ‚àé

\end{code}

We need to work with the truncation of _‚àø_ to construct the free
group, but most of the work will be done before truncation.

The following is for reasoning with chains of equivalences _‚àø_:

\begin{code}

 _‚àø‚ü®_‚ü©_ : (s : FA) {t u : FA} ‚Üí s ‚àø t ‚Üí t ‚àø u ‚Üí s ‚àø u
 _ ‚àø‚ü® p ‚ü© q = srt-transitive _‚ñ∑_ _ _ _ p q

 _‚àø‚àé : (s : FA) ‚Üí s ‚àø s
 _‚àø‚àé _ = srt-reflexive _‚ñ∑_ _

 infixr 0 _‚àø‚ü®_‚ü©_
 infix  1 _‚àø‚àé

\end{code}

The group operation before quotienting is simply concatenation.

Concatenation is a left congruence:

\begin{code}

 ++-‚ñ∑-left : (s s' t : FA) ‚Üí s ‚ñ∑ s' ‚Üí s ++ t ‚ñ∑ s' ++ t
 ++-‚ñ∑-left s s' t (u , v , x , p , q) = u , (v ++ t) , x , p' , q'
  where
   p' = s ++ t                            ‚â°‚ü® ap (_++ t) p ‚ü©
        (u ++ [ x ] ++ [ x ‚Åª ] ++ v) ++ t ‚â°‚ü® ++-assoc u ([ x ] ++ [ x ‚Åª ] ++ v) t ‚ü©
        u ++ [ x ] ++ [ x ‚Åª ] ++ v ++ t   ‚àé

   q' = s' ++ t       ‚â°‚ü® ap (_++ t) q ‚ü©
        (u ++ v) ++ t ‚â°‚ü® ++-assoc u v t ‚ü©
        u ++ v ++ t   ‚àé

 ++-‚óÅ‚ñ∑-left : (s s' t : FA) ‚Üí s ‚óÅ‚ñ∑ s' ‚Üí s ++ t ‚óÅ‚ñ∑ s' ++ t
 ++-‚óÅ‚ñ∑-left s s' t (inl a) = inl (++-‚ñ∑-left s s' t a)
 ++-‚óÅ‚ñ∑-left s s' t (inr a) = inr (++-‚ñ∑-left s' s t a)

 ++-iteration-left : (s s' t : FA) (n : ‚Ñï)
                   ‚Üí s ‚óÅ‚ñ∑[ n ] s'
                   ‚Üí s ++ t ‚óÅ‚ñ∑[ n ] s' ++ t
 ++-iteration-left s s  t zero     refl        = refl
 ++-iteration-left s s' t (succ n) (u , b , c) = (u ++ t) ,
                                                 ++-‚óÅ‚ñ∑-left s u t b ,
                                                 ++-iteration-left u s' t n c

 ++-cong-left : (s s' t : FA) ‚Üí s ‚àø s' ‚Üí s ++ t ‚àø s' ++ t
 ++-cong-left s s' t (n , a) = n , ++-iteration-left s s' t n a

\end{code}

It is also a right congruence:

\begin{code}

 ‚à∑-‚óÅ‚ñ∑ : (x : X) {s t : FA} ‚Üí s ‚óÅ‚ñ∑ t ‚Üí x ‚à∑ s ‚óÅ‚ñ∑ x ‚à∑ t
 ‚à∑-‚óÅ‚ñ∑ x (inl e) = inl (‚à∑-‚ñ∑ x e)
 ‚à∑-‚óÅ‚ñ∑ x (inr e) = inr (‚à∑-‚ñ∑ x e)

 ‚à∑-iteration : (x : X) {s t : FA} (n : ‚Ñï)
             ‚Üí s ‚óÅ‚ñ∑[ n ] t
             ‚Üí x ‚à∑ s ‚óÅ‚ñ∑[ n ] x ‚à∑ t
 ‚à∑-iteration x zero refl = refl
 ‚à∑-iteration x (succ n) (u , b , c) = (x ‚à∑ u) , ‚à∑-‚óÅ‚ñ∑ x b , ‚à∑-iteration x n c

 ‚à∑-cong : (x : X) {s t : FA} ‚Üí s ‚àø t ‚Üí x ‚à∑ s ‚àø x ‚à∑ t
 ‚à∑-cong x (n , a) = n , ‚à∑-iteration x n a

 ++-cong-right : (s {t t'} : FA) ‚Üí t ‚àø t' ‚Üí s ++ t ‚àø s ++ t'
 ++-cong-right []      e = e
 ++-cong-right (x ‚à∑ s) e = ‚à∑-cong x (++-cong-right s e)

\end{code}

And therefore it is a two-sided congruence:

\begin{code}

 ++-cong-‚àø : {s s' t t' : FA} ‚Üí s ‚àø s' ‚Üí t ‚àø t' ‚Üí s ++ t ‚àø s' ++ t'
 ++-cong-‚àø {s} {s'} {t} {t'} d e = s ++ t   ‚àø‚ü® ++-cong-left s s' t d ‚ü©
                                   s' ++ t  ‚àø‚ü® ++-cong-right s' e ‚ü©
                                   s' ++ t' ‚àø‚àé
\end{code}

The group inverse, before quotienting:

\begin{code}

 inv : FA ‚Üí FA
 inv [] = []
 inv (x ‚à∑ s) = inv s ++ [ x ‚Åª ]

\end{code}

It is a congruence:

\begin{code}

 inv-++ : (s t : FA) ‚Üí inv (s ++ t) ‚â° inv t ++ inv s
 inv-++ []      t = []-right-neutral (inv t)
 inv-++ (x ‚à∑ s) t = inv (s ++ t) ++ [ x ‚Åª ]     ‚â°‚ü® IH ‚ü©
                    (inv t ++ inv s) ++ [ x ‚Åª ] ‚â°‚ü® assoc ‚ü©
                    inv t ++ (inv s ++ [ x ‚Åª ]) ‚àé
  where
   IH    = ap (_++ [ x ‚Åª ]) (inv-++ s t)
   assoc = ++-assoc (inv t) (inv s) [ x ‚Åª ]

 inv-‚ñ∑ : {s t : FA} ‚Üí s ‚ñ∑ t ‚Üí inv s ‚ñ∑ inv t
 inv-‚ñ∑ {s} {t} (u , v , y , p , q) = inv v , inv u , y , p' , q'
  where
   p' = inv s                                     ‚â°‚ü® I ‚ü©
        inv (u ++ [ y ] ++ [ y ‚Åª ] ++ v)          ‚â°‚ü® II ‚ü©
        inv ([ y ] ++ [ y ‚Åª ] ++ v) ++ inv u      ‚â°‚ü® III ‚ü©
        inv (([ y ] ++ [ y ‚Åª ]) ++ v) ++ inv u    ‚â°‚ü® IV ‚ü©
        (inv v ++ [ (y ‚Åª)‚Åª ] ++ [ y ‚Åª ]) ++ inv u ‚â°‚ü® V ‚ü©
        (inv v ++ [ y ] ++ [ y ‚Åª ]) ++ inv u      ‚â°‚ü® VI ‚ü©
        inv v ++ [ y ] ++ [ y ‚Åª ] ++ inv u        ‚àé
    where
     I   = ap inv p
     II  = inv-++ u ([ y ] ++ [ y ‚Åª ] ++ v)
     III = ap (Œª - ‚Üí inv - ++ inv u) ((++-assoc [ y ] [ y ‚Åª ] v)‚Åª¬π)
     IV  = ap (_++ inv u) (inv-++ ([ y ] ++ [ y ‚Åª ]) v)
     V   = ap (Œª - ‚Üí (inv v ++ [ - ] ++ [ y ‚Åª ]) ++ inv u) (inv-invol y)
     VI  = ++-assoc (inv v) ([ y ] ++ [ y ‚Åª ]) (inv u)

   q' = inv t          ‚â°‚ü® ap inv q ‚ü©
        inv (u ++ v)   ‚â°‚ü® inv-++ u v ‚ü©
        inv v ++ inv u ‚àé

 inv-‚óÅ‚ñ∑ : {s t : FA} ‚Üí s ‚óÅ‚ñ∑ t ‚Üí inv s ‚óÅ‚ñ∑ inv t
 inv-‚óÅ‚ñ∑ (inl e) = inl (inv-‚ñ∑ e)
 inv-‚óÅ‚ñ∑ (inr e) = inr (inv-‚ñ∑ e)

 inv-iteration : {s t : FA} (n : ‚Ñï)
               ‚Üí s ‚óÅ‚ñ∑[ n ] t
               ‚Üí inv s ‚óÅ‚ñ∑[ n ] inv t
 inv-iteration zero refl = refl
 inv-iteration (succ n) (u , b , c) = inv u , inv-‚óÅ‚ñ∑ b , inv-iteration n c

 inv-cong-‚àø : {s t : FA} ‚Üí s ‚àø t ‚Üí inv s ‚àø inv t
 inv-cong-‚àø (n , a) = n , inv-iteration n a

\end{code}

The inverse really is an inverse:

\begin{code}

 =-‚àø : {s s' : FA} ‚Üí s ‚â° s' ‚Üí s ‚àø s'
 =-‚àø {s} refl = srt-reflexive _‚ñ∑_ s

 inv-lemma : (x : X) ‚Üí [ x ] ++ [ x ‚Åª ] ‚àø []
 inv-lemma x = srt-extension _‚ñ∑_ _ [] ([] , [] , x , refl , refl)

 inv-lemma' : (x : X) ‚Üí [ x ‚Åª ] ++ [ x ] ‚àø []
 inv-lemma' x = srt-extension _‚ñ∑_ _ _
                 ([] ,
                  [] ,
                  (x ‚Åª) ,
                  ap (Œª - ‚Üí [ x ‚Åª ] ++ [ - ]) ((inv-invol x)‚Åª¬π) , refl)

 inv-property-‚àø : (s : FA) ‚Üí s ++ inv s ‚àø []
 inv-property-‚àø []      = srt-reflexive _‚ñ∑_ []
 inv-property-‚àø (x ‚à∑ s) = Œ≥
  where
   IH : s ++ inv s ‚àø []
   IH = inv-property-‚àø s

   Œ≥ = [ x ] ++ s ++ inv s ++ [ x ‚Åª ]   ‚àø‚ü® I ‚ü©
       [ x ] ++ (s ++ inv s) ++ [ x ‚Åª ] ‚àø‚ü® II ‚ü©
       [ x ] ++ [ x ‚Åª ]                 ‚àø‚ü® III ‚ü©
       []                               ‚àø‚àé
    where
     I   = =-‚àø  (ap (x ‚à∑_) (++-assoc s (inv s) [ x ‚Åª ])‚Åª¬π)
     II  = ++-cong-right [ x ] (++-cong-left _ _ _ IH)
     III = inv-lemma x

 inv-property'-‚àø : (s : FA) ‚Üí inv s ++ s ‚àø []
 inv-property'-‚àø []      = srt-reflexive _‚ñ∑_ []
 inv-property'-‚àø (x ‚à∑ s) = Œ≥
  where
   Œ≥ = (inv s ++ [ x ‚Åª ]) ++ (x ‚à∑ s)    ‚àø‚ü® I ‚ü©
       inv s ++ ([ x ‚Åª ] ++ [ x ] ++ s) ‚àø‚ü® II ‚ü©
       inv s ++ ([ x ‚Åª ] ++ [ x ]) ++ s ‚àø‚ü® III ‚ü©
       inv s ++ s                       ‚àø‚ü® IV ‚ü©
       []                               ‚àø‚àé
    where
     I   = =-‚àø (++-assoc (inv s) [ x ‚Åª ] (x ‚à∑ s))
     II  = =-‚àø (ap (inv s ++_) ((++-assoc [ x ‚Åª ] [ x ] s)‚Åª¬π))
     III = ++-cong-right (inv s) (++-cong-left _ _ _ (inv-lemma' x))
     IV  = inv-property'-‚àø s

\end{code}

The propositional, symmetric, reflexive, transitive closure of _‚ñ∑_:

\begin{code}

 module _ (pt : propositional-truncations-exist) where

  open PropositionalTruncation pt

  _‚àæ_ : FA ‚Üí FA ‚Üí ùì§ Ãá
  x ‚àæ y = ‚à• x ‚àø y ‚à•

  infix 1 _‚àæ_

  Œ∑-‚àæ : {a b : A} ‚Üí is-set A ‚Üí Œ∑ a ‚àæ Œ∑ b ‚Üí a ‚â° b
  Œ∑-‚àæ i = ‚à•‚à•-rec i Œ∑-‚àø

  ++-cong : {s s' t t' : FA} ‚Üí s ‚àæ s' ‚Üí t ‚àæ t' ‚Üí s ++ t ‚àæ s' ++ t'
  ++-cong = ‚à•‚à•-functor‚ÇÇ ++-cong-‚àø

  inv-cong : {s t : FA} ‚Üí s ‚àæ t ‚Üí inv s ‚àæ inv t
  inv-cong = ‚à•‚à•-functor inv-cong-‚àø

  inv-property : (s : FA) ‚Üí s ++ inv s ‚àæ []
  inv-property s = ‚à£ inv-property-‚àø s ‚à£

  inv-property' : (s : FA) ‚Üí inv s ++ s ‚àæ []
  inv-property' s = ‚à£ inv-property'-‚àø s ‚à£

\end{code}

To perform the quotient, we assume functional and propositional
extensionality.

\begin{code}

  module _ (fe  : FunExt)
           (pe  : propext ùì§)
        where


   open import UF-Quotient
   open Quotient ùì§ ùì§ pt fe pe
   open psrt pt _‚ñ∑_


   ‚àæ : EqRel FA
   ‚àæ = _‚àæ_ , psrt-is-prop-valued , psrt-reflexive , psrt-symmetric , psrt-transitive

\end{code}

Our quotients constructed via propositional truncation increase
universe levels:

\begin{code}

   FA/‚àæ : ùì§ ‚Å∫ Ãá
   FA/‚àæ = FA / ‚àæ

\end{code}

This won't be a problem for our intended application, the free group
over the type of ordinals, because although this type is large, it is
locally small.

To be continued.
